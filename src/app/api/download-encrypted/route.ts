import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import crypto from 'crypto'
import fs from 'fs'
import path from 'path'
import { promisify } from 'util'
// @ts-ignore - archiver-zip-encrypted doesn't have types
import archiver from 'archiver-zip-encrypted'
import { Readable } from 'stream'

export async function POST(request: NextRequest) {
  try {
    const { slug, userEmail } = await request.json()

    if (!slug || !userEmail) {
      return NextResponse.json({ error: 'Missing slug or userEmail' }, { status: 400 })
    }

    // Get site data from database
    const supabase = await createClient()
    const { data: site, error } = await supabase
      .from('sites')
      .select('*')
      .eq('slug', slug)
      .single()

    if (error || !site) {
      return NextResponse.json({ error: 'Site not found' }, { status: 404 })
    }

    // Generate a random password for the ZIP file
    const password = crypto.randomBytes(8).toString('hex').toUpperCase()

    // Create the actual landing page HTML content
    const landingPageHtml = site.generated_html || `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${site.brand_name}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; text-align: center; }
        h1 { color: ${site.primary_color || '#333'}; }
        .cta-button { 
            background: ${site.primary_color || '#007bff'}; 
            color: white; 
            padding: 15px 30px; 
            text-decoration: none; 
            border-radius: 5px; 
            display: inline-block; 
            margin: 20px 0; 
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>${site.headline || site.brand_name}</h1>
        <p>Welcome to ${site.brand_name}</p>
        ${site.cta && site.cta_url ? `<a href="${site.cta_url}" class="cta-button">${site.cta}</a>` : ''}
    </div>
</body>
</html>
    `.trim()

    // Create configuration file
    const configContent = JSON.stringify({
      brandName: site.brand_name,
      templateId: site.template_id,
      colors: {
        primary: site.primary_color,
        secondary: site.secondary_color,
        accent: site.accent_color
      },
      content: {
        headline: site.headline,
        cta: site.cta,
        ctaUrl: site.cta_url
      },
      logo: site.logo_url,
      exportDate: new Date().toISOString()
    }, null, 2)

    // Create README file
    const readmeContent = `
# ${site.brand_name} - Landing Page Files

## üìÅ Contents
- \`index.html\` - Your complete landing page
- \`config.json\` - Site configuration and settings
- \`README.md\` - This file

## üöÄ Deployment Instructions
1. Upload \`index.html\` to your web hosting service
2. Test the page to ensure it works correctly
3. Update any links or configurations as needed

## üìß Support
If you need help, contact your account manager.

---
Generated by Olavivo PrelanderAI on ${new Date().toLocaleDateString()}
Protected with password: Check your email for access details
    `.trim()

    // Create encrypted ZIP using archiver-zip-encrypted
    const zipBuffer = await new Promise<Buffer>((resolve, reject) => {
      const chunks: Buffer[] = []
      
      // Create archiver instance with encryption
      const archive = archiver('zip-encrypted', {
        zlib: { level: 9 },
        encryptionMethod: 'aes256',
        password: password
      })

      // Handle data chunks
      archive.on('data', (chunk: Buffer) => {
        chunks.push(chunk)
      })

      // Handle completion
      archive.on('end', () => {
        resolve(Buffer.concat(chunks))
      })

      // Handle errors
      archive.on('error', (err: Error) => {
        reject(err)
      })

      // Add files to the encrypted archive
      archive.append(landingPageHtml, { name: 'index.html' })
      archive.append(configContent, { name: 'config.json' })
      archive.append(readmeContent, { name: 'README.md' })

      // Finalize the archive
      archive.finalize()
    })
    
    // Send password via email
    try {
      const emailResponse = await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/api/send-download-password`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: userEmail,
          password: password,
          siteName: site.brand_name,
          slug: slug
        }),
      })

      if (!emailResponse.ok) {
        console.error('Failed to send email')
        // Continue with download even if email fails
      }
    } catch (emailError) {
      console.error('Email sending error:', emailError)
      // Continue with download even if email fails
    }

    // Get current user for database record
    const { data: { user } } = await supabase.auth.getUser()
    
    // Store download record in database if user is authenticated
    if (user) {
      try {
        await supabase
          .from('download_passwords')
          .insert({
            site_id: site.id,
            user_id: user.id,
            password: password,
            expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours
          })
      } catch (dbError) {
        console.error('Failed to store download record:', dbError)
      }
    }

    // EMERGENCY: Use hardcoded simple filename
    const finalFilename = 'standard.zip'

    // Return the ZIP file with ultra-simple filename
    return new NextResponse(Buffer.from(zipBuffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': 'attachment; filename=standard.zip',
        'X-Download-Password': password,
      },
    })

  } catch (error) {
    console.error('Download error:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json({ 
      error: 'Failed to generate download',
      details: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? (error instanceof Error ? error.stack : '') : undefined
    }, { status: 500 })
  }
}
